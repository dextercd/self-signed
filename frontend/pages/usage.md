---
description: How to use the certificates generated by this tool. Configure the client to trust the CA certificate and have the server present its leaf certificate.
---

# Usage

In its default configuration, this web app will give you a ZIP file containing
a self-signed root/CA certificate and an end/leaf certificate signed by the CA certificate.
You also get the corresponding private keys.

The CA certificate is what should be trusted by your client software.
Most software relies on your OS' trust store but may have alternative ways to trust certificates.
Some software, notably Firefox, has its own trust store and does not use your operating system's by default.

The end/leaf certificate is what has to be presented to the client by your server software.
Your client will verify that it's signed by a trusted CA certificate and gives an error if it isn't.

## Trusting the CA certificate

You likely want your client software to trust the CA certificate so you don't get security errors when using your dev site.
Your client in this case could be a web browser or something else, such as a program calling your REST API.

You should do some web searches or consult your client, library, or browser documentation to figure out how to do this.
This page lists some methods for popular software.

### Operating Systems

- Arch Linux: [Use the `trust` program](https://wiki.archlinux.org/title/Transport_Layer_Security#Add_a_certificate_to_a_trust_store).
- Windows: https://superuser.com/a/467322
- macOS:
    - First [import the certificate](https://support.apple.com/en-gb/guide/keychain-access/kyca2431/mac)
      into your keychain then
      [adjust its trust settings](https://support.apple.com/en-gb/guide/keychain-access/kyca11871/mac).

### Browsers

- Firefox:
    - Go to Settings > Privacy & Security > Security > View Certificates:
        - Swap to the Authorities tab and import the certificate. Make sure to check the "Trust this CA to identify websites" option.
    - You can also make Firefox use your OS trust store through the
      [`security.enterprise_roots.enabled` option](https://support.mozilla.org/en-US/kb/setting-certificate-authorities-firefox).
- Chrome:
    - Chrome on Windows uses your OS trust store. On Linux, it depends on your distribution.
    - On Linux, Chrome also checks a separate trust store in your home directory.
      You can choose to add your certificate just here instead of system wide.<br>
      Go to Settings > Privacy and Security > Security > Manage certificates:
        - Swap to the Authorities tab and import the certificate. Make sure to check the "Trust this certificate for identifying websites" option.

### HTTP Clients

- cURL:
    - cURL normally uses your system's trust store, but
      some installations require the [`--ca-native`](https://curl.se/docs/manpage.html#--ca-native) option to do so.
    - You can use the command line option `--cacert path/to/ca_cert.crt` to
      trust the certificate for a single invocation.
    - https://curl.se/docs/sslcerts.html
    - [`CURLOPT_CAINFO`](https://curl.se/libcurl/c/CURLOPT_CAINFO.html)
- Python requests:
    - The requests package uses the [`certifi`](https://certifiio.readthedocs.io/en/latest/) library,
      it [does not](https://github.com/psf/requests/issues/2966) use your operating system's trust store by default.
    - There are [several options available](https://docs.python-requests.org/en/latest/user/advanced/#ssl-cert-verification)
      to make requests trust your certificate.
      You change the code or set the `REQUESTS_CA_BUNDLE` environment variable.
- OpenSSL:
    - `openssl s_client -verify_return_error -verifyCAfile path/to/ca_cert.crt -crlf -connect localhost:443`
- Postman:
    - [Documentation](https://learning.postman.com/docs/sending-requests/authorization/certificates/)


## Configuring the HTTP server

This is where you'll use the <br->[domain name].crt</br-> and <br->[domain name].key</br-> files.

### NGINX

See the [official documentation here](https://nginx.org/en/docs/http/configuring_https_servers.html), but
the gist is this:

```nginx
server {
    listen 443 ssl;
    server_name [domain name];
    ssl_certificate path/to/[domain name].crt;
    ssl_certificate_key path/to/[domain name].key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # ...
}
```

### Apache HTTP Server

Checkout the [official documentation here](https://httpd.apache.org/docs/current/ssl/ssl_howto.html).

```apache
# /usr/local/apache2/conf/httpd.conf

# ...

LoadModule socache_shmcb_module modules/mod_socache_shmcb.so
LoadModule ssl_module modules/mod_ssl.so

# Secure (SSL/TLS) connections
Include conf/extra/httpd-ssl.conf

# ...
```

```apache
# /usr/local/apache2/conf/extra/httpd-ssl.conf

# ...

SSLCertificateFile "path/to/[domain name].crt"
SSLCertificateKeyFile "path/to/[domain name].key"

# ...
```

### Caddy

See the full documentation for the [`tls` directive](https://caddyserver.com/docs/caddyfile/directives/tls).

<pre><code class="hljs"><span class="hljs-section">[domain name]</span> {
    <span class="hljs-attribute">tls</span> <span class="hljs-string">"path/to/[domain name].crt"</span> <span class="hljs-string">"path/to/[domain name].key"</span>

    <span class="hljs-comment"># ...</span>
}</code></pre>

### HAProxy

For more details, see the [HAProxy TLS Documentation](https://www.haproxy.com/documentation/haproxy-configuration-tutorials/ssl-tls/).

For HAProxy, you must combine the certificate and key into one file with the key
coming last. On a Unix-like OS, you can do that with the following command:

```sh
$ cat "path/to/[domain name].crt" "path/to/[domain name].key" >"path/to/[domain name].combined.crt"
```

```apache
# ...

frontend www
    bind :80
    bind :443 ssl crt path/to/[domain name].combined.crt

    http-request redirect scheme https unless { ssl_fc }

    # ...
```

### Lighttpd

[Lighttpd TLS documentation](https://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_SSL).

```php
# ...

server.modules += ("mod_openssl")
$SERVER["socket"] == ":443" {
    ssl.engine = "enable"
    ssl.pemfile = "path/to/[domain name].crt"
    ssl.privkey = "path/to/[domain name].key"
}
```

### NPM http-server

See all [available run options](https://github.com/http-party/http-server#available-options).

```sh
$ npx http-server --tls --cert "path/to/[domain name].crt" --key "path/to/[domain name].key" dist/
```

### Node.js

Also see the [official documentation](https://nodejs.org/api/https.html#httpscreateserveroptions-requestlistener).

```js
const https = require('node:https');
const fs = require('node:fs');

const options = {
    cert: fs.readFileSync('path/to/[domain name].crt'),
    key: fs.readFileSync('path/to/[domain name].key'),
};

https.createServer(options, (req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
}).listen(443); 
```

### Cowboy

Use [`cowboy:start_tls/3`](https://ninenines.eu/docs/en/cowboy/2.12/manual/cowboy.start_tls/) along with the `certfile` and `keyfile` [`ranch_ssl:opts()` options](https://ninenines.eu/docs/en/ranch/2.1/manual/ranch_ssl/#_ssl_opt).

```erlang
start(_StartType, _StartArgs) ->
    Dispatch = cowboy_router:compile([
        {'_', [{"/", hello_handler, []}]}
    ]),
    {ok, _} = cowboy:start_tls(my_https_listener,
        [{port, 443},
         {certfile, "path/to/[domain name].crt"},
         {keyfile, "path/to/[domain name].key"}],
        #{env => #{dispatch => Dispatch}}
    ),
    tls_example_sup:start_link().
```

### Kestrel

See the [Kestrel Endpoint configuration](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel/endpoints#configure-https) docs.

Add something like the following into your `appsettings.json`:

```json
{
  // ...

  "Kestrel": {
    "Endpoints": {
      "Https": {
        "Url": "https://localhost:443",
        "Certificate": {
          "Path": "path/to/[domain name].crt",
          "KeyPath": "path/to/[domain name].key"
        }
      }
    }
  }
}
```

### Gunicorn

Gunicorn [SSL settings](https://docs.gunicorn.org/en/stable/settings.html#ssl).

There are various ways to configure Gunicorn, this example uses the command line:

```sh
gunicorn                                   \
    --bind :443                            \
    --certfile "path/to/[domain name].crt" \
    --keyfile "path/to/[domain name].key"  \
    app:app
```

### Uvicorn

Uvicorn [HTTPS settings](https://www.uvicorn.org/settings/#https).

```sh
uvicorn                                        \
    --port 443                                 \
    --ssl-certfile="path/to/[domain name].crt" \
    --ssl-keyfile="path/to/[domain name].key"  \
    app:app
```

### uWSGI

uWSGI [HTTPS support](https://uwsgi-docs.readthedocs.io/en/latest/HTTPS.html).

```sh
uwsgi \
    --https "0.0.0.0:443,path/to/[domain name].crt,path/to/[domain name].key,HIGH" \
    --wsgi-file app.py
```
